ChatGoogleGenerativeAI
class langchain_google_genai.chat_models.ChatGoogleGenerativeAI[source]
Bases: _BaseGoogleGenerativeAI, BaseChatModel

Google AI chat models integration.

Instantiation:
To use, you must have either:

The GOOGLE_API_KEY environment variable set with your API key, or

2. Pass your API key using the google_api_key kwarg to the ChatGoogleGenerativeAI constructor.

from langchain_google_genai import ChatGoogleGenerativeAI

llm = ChatGoogleGenerativeAI(model="gemini-2.0-flash-001")
llm.invoke("Write me a ballad about LangChain")
Invoke:
messages = [
    ("system", "Translate the user sentence to French."),
    ("human", "I love programming."),
]
llm.invoke(messages)
AIMessage(
    content="J'adore programmer. \n",
    response_metadata={'prompt_feedback': {'block_reason': 0, 'safety_ratings': []}, 'finish_reason': 'STOP', 'safety_ratings': [{'category': 'HARM_CATEGORY_SEXUALLY_EXPLICIT', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_HATE_SPEECH', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_HARASSMENT', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_DANGEROUS_CONTENT', 'probability': 'NEGLIGIBLE', 'blocked': False}]},
    id='run-56cecc34-2e54-4b52-a974-337e47008ad2-0',
    usage_metadata={'input_tokens': 18, 'output_tokens': 5, 'total_tokens': 23}
)
Stream:
for chunk in llm.stream(messages):
    print(chunk)
AIMessageChunk(content='J', response_metadata={'finish_reason': 'STOP', 'safety_ratings': []}, id='run-e905f4f4-58cb-4a10-a960-448a2bb649e3', usage_metadata={'input_tokens': 18, 'output_tokens': 1, 'total_tokens': 19})
AIMessageChunk(content="'adore programmer. \n", response_metadata={'finish_reason': 'STOP', 'safety_ratings': [{'category': 'HARM_CATEGORY_SEXUALLY_EXPLICIT', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_HATE_SPEECH', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_HARASSMENT', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_DANGEROUS_CONTENT', 'probability': 'NEGLIGIBLE', 'blocked': False}]}, id='run-e905f4f4-58cb-4a10-a960-448a2bb649e3', usage_metadata={'input_tokens': 18, 'output_tokens': 5, 'total_tokens': 23})
stream = llm.stream(messages)
full = next(stream)
for chunk in stream:
    full += chunk
full
AIMessageChunk(
    content="J'adore programmer. \n",
    response_metadata={'finish_reason': 'STOPSTOP', 'safety_ratings': [{'category': 'HARM_CATEGORY_SEXUALLY_EXPLICIT', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_HATE_SPEECH', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_HARASSMENT', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_DANGEROUS_CONTENT', 'probability': 'NEGLIGIBLE', 'blocked': False}]},
    id='run-3ce13a42-cd30-4ad7-a684-f1f0b37cdeec',
    usage_metadata={'input_tokens': 36, 'output_tokens': 6, 'total_tokens': 42}
)
Async:
await llm.ainvoke(messages)

# stream:
# async for chunk in (await llm.astream(messages))

# batch:
# await llm.abatch([messages])
Context Caching:
Context caching allows you to store and reuse content (e.g., PDFs, images) for faster processing. The cached_content parameter accepts a cache name created via the Google Generative AI API. Below are two examples: caching a single file directly and caching multiple files using Part.

Single File Example: This caches a single file and queries it.

from google import genai
from google.genai import types
import time
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.messages import HumanMessage

client = genai.Client()

# Upload file
file = client.files.upload(file="./example_file")
while file.state.name == 'PROCESSING':
    time.sleep(2)
    file = client.files.get(name=file.name)

# Create cache
model = 'models/gemini-1.5-flash-latest'
cache = client.caches.create(
    model=model,
    config=types.CreateCachedContentConfig(
        display_name='Cached Content',
        system_instruction=(
            'You are an expert content analyzer, and your job is to answer '
            'the user's query based on the file you have access to.'
        ),
        contents=[file],
        ttl="300s",
    )
)

# Query with LangChain
llm = ChatGoogleGenerativeAI(
    model=model,
    cached_content=cache.name,
)
message = HumanMessage(content="Summarize the main points of the content.")
llm.invoke([message])
Multiple Files Example: This caches two files using Part and queries them together.

from google import genai
from google.genai.types import CreateCachedContentConfig, Content, Part
import time
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.messages import HumanMessage

client = genai.Client()

# Upload files
file_1 = client.files.upload(file="./file1")
while file_1.state.name == 'PROCESSING':
    time.sleep(2)
    file_1 = client.files.get(name=file_1.name)

file_2 = client.files.upload(file="./file2")
while file_2.state.name == 'PROCESSING':
    time.sleep(2)
    file_2 = client.files.get(name=file_2.name)

# Create cache with multiple files
contents = [
    Content(
        role="user",
        parts=[
            Part.from_uri(file_uri=file_1.uri, mime_type=file_1.mime_type),
            Part.from_uri(file_uri=file_2.uri, mime_type=file_2.mime_type),
        ],
    )
]
model = "gemini-1.5-flash-latest"
cache = client.caches.create(
    model=model,
    config=CreateCachedContentConfig(
        display_name='Cached Contents',
        system_instruction=(
            'You are an expert content analyzer, and your job is to answer '
            'the user's query based on the files you have access to.'
        ),
        contents=contents,
        ttl="300s",
    )
)

# Query with LangChain
llm = ChatGoogleGenerativeAI(
    model=model,
    cached_content=cache.name,
)
message = HumanMessage(content="Provide a summary of the key information across both files.")
llm.invoke([message])
Tool calling:
from pydantic import BaseModel, Field


class GetWeather(BaseModel):
    '''Get the current weather in a given location'''

    location: str = Field(
        ..., description="The city and state, e.g. San Francisco, CA"
    )


class GetPopulation(BaseModel):
    '''Get the current population in a given location'''

    location: str = Field(
        ..., description="The city and state, e.g. San Francisco, CA"
    )


llm_with_tools = llm.bind_tools([GetWeather, GetPopulation])
ai_msg = llm_with_tools.invoke(
    "Which city is hotter today and which is bigger: LA or NY?"
)
ai_msg.tool_calls
[{'name': 'GetWeather',
  'args': {'location': 'Los Angeles, CA'},
  'id': 'c186c99f-f137-4d52-947f-9e3deabba6f6'},
 {'name': 'GetWeather',
  'args': {'location': 'New York City, NY'},
  'id': 'cebd4a5d-e800-4fa5-babd-4aa286af4f31'},
 {'name': 'GetPopulation',
  'args': {'location': 'Los Angeles, CA'},
  'id': '4f92d897-f5e4-4d34-a3bc-93062c92591e'},
 {'name': 'GetPopulation',
  'args': {'location': 'New York City, NY'},
  'id': '634582de-5186-4e4b-968b-f192f0a93678'}]
Use Search with Gemini 2:
from google.ai.generativelanguage_v1beta.types import Tool as GenAITool
llm = ChatGoogleGenerativeAI(model="gemini-2.0-flash-exp")
resp = llm.invoke(
    "When is the next total solar eclipse in US?",
    tools=[GenAITool(google_search={})],
)
Structured output:
from typing import Optional

from pydantic import BaseModel, Field


class Joke(BaseModel):
    '''Joke to tell user.'''

    setup: str = Field(description="The setup of the joke")
    punchline: str = Field(description="The punchline to the joke")
    rating: Optional[int] = Field(description="How funny the joke is, from 1 to 10")


structured_llm = llm.with_structured_output(Joke)
structured_llm.invoke("Tell me a joke about cats")
Joke(
    setup='Why are cats so good at video games?',
    punchline='They have nine lives on the internet',
    rating=None
)
Image input:
import base64
import httpx
from langchain_core.messages import HumanMessage

image_url = "https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg"
image_data = base64.b64encode(httpx.get(image_url).content).decode("utf-8")
message = HumanMessage(
    content=[
        {"type": "text", "text": "describe the weather in this image"},
        {
            "type": "image_url",
            "image_url": {"url": f"data:image/jpeg;base64,{image_data}"},
        },
    ]
)
ai_msg = llm.invoke([message])
ai_msg.content
'The weather in this image appears to be sunny and pleasant. The sky is a bright blue with scattered white clouds, suggesting fair weather. The lush green grass and trees indicate a warm and possibly slightly breezy day. There are no signs of rain or storms.'
Token usage:
ai_msg = llm.invoke(messages)
ai_msg.usage_metadata
{'input_tokens': 18, 'output_tokens': 5, 'total_tokens': 23}
Response metadata
ai_msg = llm.invoke(messages)
ai_msg.response_metadata
{
    'prompt_feedback': {'block_reason': 0, 'safety_ratings': []},
    'finish_reason': 'STOP',
    'safety_ratings': [{'category': 'HARM_CATEGORY_SEXUALLY_EXPLICIT', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_HATE_SPEECH', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_HARASSMENT', 'probability': 'NEGLIGIBLE', 'blocked': False}, {'category': 'HARM_CATEGORY_DANGEROUS_CONTENT', 'probability': 'NEGLIGIBLE', 'blocked': False}]
}
Needed for arg validation.

Note

ChatGoogleGenerativeAI implements the standard Runnable Interface. ðŸƒ

The Runnable Interface has additional methods that are available on runnables, such as with_config, with_types, with_retry, assign, bind, get_graph, and more.

param additional_headers: Dict[str, str] | None = None
A key-value dictionary representing additional headers for the model call

param cache: BaseCache | bool | None = None
Whether to cache the response.

If true, will use the global cache.

If false, will not use a cache

If None, will use the global cache if itâ€™s set, otherwise no cache.

If instance of BaseCache, will use the provided cache.

Caching is not currently supported for streaming methods of models.

param cached_content: str | None = None
The name of the cached content used as context to serve the prediction.

Note: only used in explicit caching, where users can have control over caching (e.g. what content to cache) and enjoy guaranteed cost savings. Format: cachedContents/{cachedContent}.

param callback_manager: BaseCallbackManager | None = None
Deprecated since version 0.1.7: Use callbacks() instead. It will be removed in pydantic==1.0.

Callback manager to add to the run trace.

param callbacks: Callbacks = None
Callbacks to add to the run trace.

param client_options: Dict | None = None
A dictionary of client options to pass to the Google API client, such as api_endpoint.

param convert_system_message_to_human: bool = False
Whether to merge any leading SystemMessage into the following HumanMessage.

Gemini does not support system messages; any unsupported messages will raise an error.

param credentials: Any = None
The default custom credentials (google.auth.credentials.Credentials) to use

param custom_get_token_ids: Callable[[str], list[int]] | None = None
Optional encoder to use for counting tokens.

param disable_streaming: bool | Literal['tool_calling'] = False
Whether to disable streaming for this model.

If streaming is bypassed, then stream()/astream()/astream_events() will defer to invoke()/ainvoke().

If True, will always bypass streaming case.

If 'tool_calling', will bypass streaming case only when the model is called with a tools keyword argument. In other words, LangChain will automatically switch to non-streaming behavior (invoke()) only when the tools argument is provided. This offers the best of both worlds.

If False (default), will always use streaming case if available.

The main reason for this flag is that code might be written using .stream() and a user may want to swap out a given model for another model whose the implementation does not properly support streaming.

param google_api_key: SecretStr | None [Optional] (alias 'api_key')
Google AI API key. If not specified will be read from env var GOOGLE_API_KEY.

param include_thoughts: bool | None = None
Indicates whether to include thoughts in the response.

param max_output_tokens: int | None = None (alias 'max_tokens')
Maximum number of tokens to include in a candidate. Must be greater than zero. If unset, will default to 64.

param max_retries: int = 6
The maximum number of retries to make when generating.

param metadata: dict[str, Any] | None = None
Metadata to add to the run trace.

param model: str [Required]
Model name to use.

The name of the model to use. Supported examples:

gemini-pro

models/text-bison-001

param model_kwargs: dict[str, Any] [Optional]
Holds any unexpected initialization parameters.

param n: int = 1
Number of chat completions to generate for each prompt. Note that the API may not return the full n completions if duplicates are generated.

param rate_limiter: BaseRateLimiter | None = None
An optional rate limiter to use for limiting the number of requests.

param response_mime_type: str | None = None
Optional. Output response mimetype of the generated candidate text. Only
supported in Gemini 1.5 and later models. Supported mimetype:
â€œtext/plainâ€: (default) Text output.

â€œapplication/jsonâ€: JSON response in the candidates.

â€œtext/x.enumâ€: Enum in plain text.

The model also needs to be prompted to output the appropriate response type, otherwise the behavior is undefined. This is a preview feature.

param response_modalities: List[Modality] | None = None
A list of modalities of the response

param response_schema: Dict[str, Any] | None = None
Optional. Enforce an schema to the output. The format of the dictionary should follow Open API schema.

param safety_settings: Dict[HarmCategory, HarmBlockThreshold] | None = None
The default safety settings to use for all generations.

For example:

from google.generativeai.types.safety_types import HarmBlockThreshold, HarmCategory

safety_settings = {
HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE, HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_ONLY_HIGH, HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_LOW_AND_ABOVE, HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_NONE,

}

param tags: list[str] | None = None
Tags to add to the run trace.

param temperature: float = 0.7
Run inference with this temperature. Must by in the closed interval [0.0, 2.0].

param thinking_budget: int | None = None
Indicates the thinking budget in tokens.

param timeout: float | None = None
The maximum number of seconds to wait for a response.

param top_k: int | None = None
Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive.

param top_p: float | None = None
Decode using nucleus sampling: consider the smallest set of tokens whose probability sum is at least top_p. Must be in the closed interval [0.0, 1.0].

param transport: str | None = None
A string, one of: [rest, grpc, grpc_asyncio].

param verbose: bool [Optional]
Whether to print out response text.

__call__(
messages: list[BaseMessage],
stop: list[str] | None = None,
callbacks: list[BaseCallbackHandler] | BaseCallbackManager | None = None,
**kwargs: Any,
) â†’ BaseMessage
Deprecated since version 0.1.7: Use invoke() instead. It will not be removed until langchain-core==1.0.

Call the model.

Parameters
:
messages (list[BaseMessage]) â€“ List of messages.

stop (list[str] | None) â€“ Stop words to use when generating. Model output is cut off at the first occurrence of any of these substrings.

callbacks (list[BaseCallbackHandler] | BaseCallbackManager | None) â€“ Callbacks to pass through. Used for executing additional functionality, such as logging or streaming, throughout generation.

**kwargs (Any) â€“ Arbitrary additional keyword arguments. These are usually passed to the model provider API call.

Returns
:
The model output message.

Return type
:
BaseMessage

async abatch(
inputs: list[Input],
config: RunnableConfig | list[RunnableConfig] | None = None,
*,
return_exceptions: bool = False,
**kwargs: Any | None,
) â†’ list[Output]
Default implementation runs ainvoke in parallel using asyncio.gather.

The default implementation of batch works well for IO bound runnables.

Subclasses should override this method if they can batch more efficiently; e.g., if the underlying Runnable uses an API which supports a batch mode.

Parameters
:
inputs (list[Input]) â€“ A list of inputs to the Runnable.

config (RunnableConfig | list[RunnableConfig] | None) â€“ A config to use when invoking the Runnable. The config supports standard keys like â€˜tagsâ€™, â€˜metadataâ€™ for tracing purposes, â€˜max_concurrencyâ€™ for controlling how much work to do in parallel, and other keys. Please refer to the RunnableConfig for more details. Defaults to None.

return_exceptions (bool) â€“ Whether to return exceptions instead of raising them. Defaults to False.

kwargs (Any | None) â€“ Additional keyword arguments to pass to the Runnable.

Returns
:
A list of outputs from the Runnable.

Return type
:
list[Output]

async abatch_as_completed(
inputs: Sequence[Input],
config: RunnableConfig | Sequence[RunnableConfig] | None = None,
*,
return_exceptions: bool = False,
**kwargs: Any | None,
) â†’ AsyncIterator[tuple[int, Output | Exception]]
Run ainvoke in parallel on a list of inputs.

Yields results as they complete.

Parameters
:
inputs (Sequence[Input]) â€“ A list of inputs to the Runnable.

config (RunnableConfig | Sequence[RunnableConfig] | None) â€“ A config to use when invoking the Runnable. The config supports standard keys like â€˜tagsâ€™, â€˜metadataâ€™ for tracing purposes, â€˜max_concurrencyâ€™ for controlling how much work to do in parallel, and other keys. Please refer to the RunnableConfig for more details. Defaults to None. Defaults to None.

return_exceptions (bool) â€“ Whether to return exceptions instead of raising them. Defaults to False.

kwargs (Any | None) â€“ Additional keyword arguments to pass to the Runnable.

Yields
:
A tuple of the index of the input and the output from the Runnable.

Return type
:
AsyncIterator[tuple[int, Output | Exception]]

async ainvoke(
input: LanguageModelInput,
config: RunnableConfig | None = None,
*,
stop: list[str] | None = None,
**kwargs: Any,
) â†’ BaseMessage
Default implementation of ainvoke, calls invoke from a thread.

The default implementation allows usage of async code even if the Runnable did not implement a native async version of invoke.

Subclasses should override this method if they can run asynchronously.

Parameters
:
input (LanguageModelInput)

config (Optional[RunnableConfig])

stop (Optional[list[str]])

kwargs (Any)

Return type
:
BaseMessage

async astream(
input: LanguageModelInput,
config: RunnableConfig | None = None,
*,
stop: list[str] | None = None,
**kwargs: Any,
) â†’ AsyncIterator[BaseMessageChunk]
Default implementation of astream, which calls ainvoke.

Subclasses should override this method if they support streaming output.

Parameters
:
input (LanguageModelInput) â€“ The input to the Runnable.

config (Optional[RunnableConfig]) â€“ The config to use for the Runnable. Defaults to None.

kwargs (Any) â€“ Additional keyword arguments to pass to the Runnable.

stop (Optional[list[str]])

Yields
:
The output of the Runnable.

Return type
:
AsyncIterator[BaseMessageChunk]

async astream_events(
input: Any,
config: RunnableConfig | None = None,
*,
version: Literal['v1', 'v2'] = 'v2',
include_names: Sequence[str] | None = None,
include_types: Sequence[str] | None = None,
include_tags: Sequence[str] | None = None,
exclude_names: Sequence[str] | None = None,
exclude_types: Sequence[str] | None = None,
exclude_tags: Sequence[str] | None = None,
**kwargs: Any,
) â†’ AsyncIterator[StreamEvent]
Generate a stream of events.

Use to create an iterator over StreamEvents that provide real-time information about the progress of the Runnable, including StreamEvents from intermediate results.

A StreamEvent is a dictionary with the following schema:

event: str - Event names are of the
format: on_[runnable_type]_(start|stream|end).

name: str - The name of the Runnable that generated the event.

run_id: str - randomly generated ID associated with the given execution of
the Runnable that emitted the event. A child Runnable that gets invoked as part of the execution of a parent Runnable is assigned its own unique ID.

parent_ids: list[str] - The IDs of the parent runnables that
generated the event. The root Runnable will have an empty list. The order of the parent IDs is from the root to the immediate parent. Only available for v2 version of the API. The v1 version of the API will return an empty list.

tags: Optional[list[str]] - The tags of the Runnable that generated
the event.

metadata: Optional[dict[str, Any]] - The metadata of the Runnable
that generated the event.

data: dict[str, Any]

Below is a table that illustrates some events that might be emitted by various chains. Metadata fields have been omitted from the table for brevity. Chain definitions have been included after the table.

ATTENTION This reference table is for the V2 version of the schema.

event

name

chunk

input

output

on_chat_model_start

[model name]

{â€œmessagesâ€: [[SystemMessage, HumanMessage]]}

on_chat_model_stream

[model name]

AIMessageChunk(content=â€helloâ€)

on_chat_model_end

[model name]

{â€œmessagesâ€: [[SystemMessage, HumanMessage]]}

AIMessageChunk(content=â€hello worldâ€)

on_llm_start

[model name]

{â€˜inputâ€™: â€˜helloâ€™}

on_llm_stream

[model name]

â€˜Helloâ€™

on_llm_end

[model name]

â€˜Hello human!â€™

on_chain_start

format_docs

on_chain_stream

format_docs

â€œhello world!, goodbye world!â€

on_chain_end

format_docs

[Document(â€¦)]

â€œhello world!, goodbye world!â€

on_tool_start

some_tool

{â€œxâ€: 1, â€œyâ€: â€œ2â€}

on_tool_end

some_tool

{â€œxâ€: 1, â€œyâ€: â€œ2â€}

on_retriever_start

[retriever name]

{â€œqueryâ€: â€œhelloâ€}

on_retriever_end

[retriever name]

{â€œqueryâ€: â€œhelloâ€}

[Document(â€¦), ..]

on_prompt_start

[template_name]

{â€œquestionâ€: â€œhelloâ€}

on_prompt_end

[template_name]

{â€œquestionâ€: â€œhelloâ€}

ChatPromptValue(messages: [SystemMessage, â€¦])

In addition to the standard events, users can also dispatch custom events (see example below).

Custom events will be only be surfaced with in the v2 version of the API!

A custom event has following format:

Attribute

Type

Description

name

str

A user defined name for the event.

data

Any

The data associated with the event. This can be anything, though we suggest making it JSON serializable.

Here are declarations associated with the standard events shown above:

format_docs:

def format_docs(docs: list[Document]) -> str:
    '''Format the docs.'''
    return ", ".join([doc.page_content for doc in docs])

format_docs = RunnableLambda(format_docs)
some_tool:

@tool
def some_tool(x: int, y: str) -> dict:
    '''Some_tool.'''
    return {"x": x, "y": y}
prompt:

template = ChatPromptTemplate.from_messages(
    [("system", "You are Cat Agent 007"), ("human", "{question}")]
).with_config({"run_name": "my_template", "tags": ["my_template"]})
Example:

from langchain_core.runnables import RunnableLambda

async def reverse(s: str) -> str:
    return s[::-1]

chain = RunnableLambda(func=reverse)

events = [
    event async for event in chain.astream_events("hello", version="v2")
]

# will produce the following events (run_id, and parent_ids
# has been omitted for brevity):
[
    {
        "data": {"input": "hello"},
        "event": "on_chain_start",
        "metadata": {},
        "name": "reverse",
        "tags": [],
    },
    {
        "data": {"chunk": "olleh"},
        "event": "on_chain_stream",
        "metadata": {},
        "name": "reverse",
        "tags": [],
    },
    {
        "data": {"output": "olleh"},
        "event": "on_chain_end",
        "metadata": {},
        "name": "reverse",
        "tags": [],
    },
]
Example: Dispatch Custom Event

from langchain_core.callbacks.manager import (
    adispatch_custom_event,
)
from langchain_core.runnables import RunnableLambda, RunnableConfig
import asyncio


async def slow_thing(some_input: str, config: RunnableConfig) -> str:
    """Do something that takes a long time."""
    await asyncio.sleep(1) # Placeholder for some slow operation
    await adispatch_custom_event(
        "progress_event",
        {"message": "Finished step 1 of 3"},
        config=config # Must be included for python < 3.10
    )
    await asyncio.sleep(1) # Placeholder for some slow operation
    await adispatch_custom_event(
        "progress_event",
        {"message": "Finished step 2 of 3"},
        config=config # Must be included for python < 3.10
    )
    await asyncio.sleep(1) # Placeholder for some slow operation
    return "Done"

slow_thing = RunnableLambda(slow_thing)

async for event in slow_thing.astream_events("some_input", version="v2"):
    print(event)
Parameters
:
input (Any) â€“ The input to the Runnable.

config (Optional[RunnableConfig]) â€“ The config to use for the Runnable.

version (Literal['v1', 'v2']) â€“ The version of the schema to use either v2 or v1. Users should use v2. v1 is for backwards compatibility and will be deprecated in 0.4.0. No default will be assigned until the API is stabilized. custom events will only be surfaced in v2.

include_names (Optional[Sequence[str]]) â€“ Only include events from runnables with matching names.

include_types (Optional[Sequence[str]]) â€“ Only include events from runnables with matching types.

include_tags (Optional[Sequence[str]]) â€“ Only include events from runnables with matching tags.

exclude_names (Optional[Sequence[str]]) â€“ Exclude events from runnables with matching names.

exclude_types (Optional[Sequence[str]]) â€“ Exclude events from runnables with matching types.

exclude_tags (Optional[Sequence[str]]) â€“ Exclude events from runnables with matching tags.

kwargs (Any) â€“ Additional keyword arguments to pass to the Runnable. These will be passed to astream_log as this implementation of astream_events is built on top of astream_log.

Yields
:
An async stream of StreamEvents.

Raises
:
NotImplementedError â€“ If the version is not v1 or v2.

Return type
:
AsyncIterator[StreamEvent]

batch(
inputs: list[Input],
config: RunnableConfig | list[RunnableConfig] | None = None,
*,
return_exceptions: bool = False,
**kwargs: Any | None,
) â†’ list[Output]
Default implementation runs invoke in parallel using a thread pool executor.

The default implementation of batch works well for IO bound runnables.

Subclasses should override this method if they can batch more efficiently; e.g., if the underlying Runnable uses an API which supports a batch mode.

Parameters
:
inputs (list[Input])

config (RunnableConfig | list[RunnableConfig] | None)

return_exceptions (bool)

kwargs (Any | None)

Return type
:
list[Output]

batch_as_completed(
inputs: Sequence[Input],
config: RunnableConfig | Sequence[RunnableConfig] | None = None,
*,
return_exceptions: bool = False,
**kwargs: Any | None,
) â†’ Iterator[tuple[int, Output | Exception]]
Run invoke in parallel on a list of inputs.

Yields results as they complete.

Parameters
:
inputs (Sequence[Input])

config (RunnableConfig | Sequence[RunnableConfig] | None)

return_exceptions (bool)

kwargs (Any | None)

Return type
:
Iterator[tuple[int, Output | Exception]]

bind(
**kwargs: Any,
) â†’ Runnable[Input, Output]
Bind arguments to a Runnable, returning a new Runnable.

Useful when a Runnable in a chain requires an argument that is not in the output of the previous Runnable or included in the user input.

Parameters
:
kwargs (Any) â€“ The arguments to bind to the Runnable.

Returns
:
A new Runnable with the arguments bound.

Return type
:
Runnable[Input, Output]

Example:

from langchain_ollama import ChatOllama
from langchain_core.output_parsers import StrOutputParser

llm = ChatOllama(model='llama2')

# Without bind.
chain = (
    llm
    | StrOutputParser()
)

chain.invoke("Repeat quoted words exactly: 'One two three four five.'")
# Output is 'One two three four five.'

# With bind.
chain = (
    llm.bind(stop=["three"])
    | StrOutputParser()
)

chain.invoke("Repeat quoted words exactly: 'One two three four five.'")
# Output is 'One two'
bind_tools(
tools: Sequence[dict[str, Any] | type | Callable[[...], Any] | BaseTool | Tool],
tool_config: Dict | _ToolConfigDict | None = None,
*,
tool_choice: dict | List[str] | str | Literal['auto', 'none', 'any'] | Literal[True] | bool | None = None,
**kwargs: Any,
) â†’ Runnable[PromptValue | str | Sequence[BaseMessage | list[str] | tuple[str, str] | str | dict[str, Any]], BaseMessage][source]
Bind tool-like objects to this chat model.

Assumes model is compatible with google-generativeAI tool-calling API.

Parameters
:
tools (Sequence[dict[str, Any] | type | Callable[[...], Any] | BaseTool | Tool]) â€“ A list of tool definitions to bind to this chat model. Can be a pydantic model, callable, or BaseTool. Pydantic models, callables, and BaseTools will be automatically converted to their schema dictionary representation.

**kwargs (Any) â€“ Any additional parameters to pass to the Runnable constructor.

tool_config (Dict | _ToolConfigDict | None)

tool_choice (dict | List[str] | str | Literal['auto', 'none', 'any'] | ~typing.Literal[True] | bool | None)

**kwargs

Return type
:
Runnable[PromptValue | str | Sequence[BaseMessage | list[str] | tuple[str, str] | str | dict[str, Any]], BaseMessage]

configurable_alternatives(
which: ConfigurableField,
*,
default_key: str = 'default',
prefix_keys: bool = False,
**kwargs: Runnable[Input, Output] | Callable[[], Runnable[Input, Output]],
) â†’ RunnableSerializable
Configure alternatives for Runnables that can be set at runtime.

Parameters
:
which (ConfigurableField) â€“ The ConfigurableField instance that will be used to select the alternative.

default_key (str) â€“ The default key to use if no alternative is selected. Defaults to â€œdefaultâ€.

prefix_keys (bool) â€“ Whether to prefix the keys with the ConfigurableField id. Defaults to False.

**kwargs (Runnable[Input, Output] | Callable[[], Runnable[Input, Output]]) â€“ A dictionary of keys to Runnable instances or callables that return Runnable instances.

Returns
:
A new Runnable with the alternatives configured.

Return type
:
RunnableSerializable

from langchain_anthropic import ChatAnthropic
from langchain_core.runnables.utils import ConfigurableField
from langchain_openai import ChatOpenAI

model = ChatAnthropic(
    model_name="claude-3-sonnet-20240229"
).configurable_alternatives(
    ConfigurableField(id="llm"),
    default_key="anthropic",
    openai=ChatOpenAI()
)

# uses the default model ChatAnthropic
print(model.invoke("which organization created you?").content)

# uses ChatOpenAI
print(
    model.with_config(
        configurable={"llm": "openai"}
    ).invoke("which organization created you?").content
)
configurable_fields(
**kwargs: ConfigurableField | ConfigurableFieldSingleOption | ConfigurableFieldMultiOption,
) â†’ RunnableSerializable
Configure particular Runnable fields at runtime.

Parameters
:
**kwargs (ConfigurableField | ConfigurableFieldSingleOption | ConfigurableFieldMultiOption) â€“ A dictionary of ConfigurableField instances to configure.

Returns
:
A new Runnable with the fields configured.

Return type
:
RunnableSerializable

from langchain_core.runnables import ConfigurableField
from langchain_openai import ChatOpenAI

model = ChatOpenAI(max_tokens=20).configurable_fields(
    max_tokens=ConfigurableField(
        id="output_token_number",
        name="Max tokens in the output",
        description="The maximum number of tokens in the output",
    )
)

# max_tokens = 20
print(
    "max_tokens_20: ",
    model.invoke("tell me something about chess").content
)

# max_tokens = 200
print("max_tokens_200: ", model.with_config(
    configurable={"output_token_number": 200}
    ).invoke("tell me something about chess").content
)
get_num_tokens(text: str) â†’ int[source]
Get the number of tokens present in the text.

Useful for checking if an input will fit in a modelâ€™s context window.

Parameters
:
text (str) â€“ The string input to tokenize.

Returns
:
The integer number of tokens in the text.

Return type
:
int

get_num_tokens_from_messages(
messages: list[BaseMessage],
tools: Sequence | None = None,
) â†’ int
Get the number of tokens in the messages.

Useful for checking if an input fits in a modelâ€™s context window.

Note: the base implementation of get_num_tokens_from_messages ignores tool schemas.

Parameters
:
messages (list[BaseMessage]) â€“ The message inputs to tokenize.

tools (Sequence | None) â€“ If provided, sequence of dict, BaseModel, function, or BaseTools to be converted to tool schemas.

Returns
:
The sum of the number of tokens across the messages.

Return type
:
int

get_token_ids(text: str) â†’ list[int]
Return the ordered ids of the tokens in a text.

Parameters
:
text (str) â€“ The string input to tokenize.

Returns
:
A list of ids corresponding to the tokens in the text, in order they occur
in the text.

Return type
:
list[int]

invoke(
input: PromptValue | str | Sequence[BaseMessage | list[str] | tuple[str, str] | str | dict[str, Any]],
config: RunnableConfig | None = None,
*,
code_execution: bool | None = None,
stop: list[str] | None = None,
**kwargs: Any,
) â†’ BaseMessage[source]
Enable code execution. Supported on: gemini-1.5-pro, gemini-1.5-flash, gemini-2.0-flash, and gemini-2.0-pro. When enabled, the model can execute code to solve problems.

Parameters
:
input (PromptValue | str | Sequence[BaseMessage | list[str] | tuple[str, str] | str | dict[str, Any]])

config (RunnableConfig | None)

code_execution (bool | None)

stop (list[str] | None)

kwargs (Any)

Return type
:
BaseMessage

stream(
input: LanguageModelInput,
config: RunnableConfig | None = None,
*,
stop: list[str] | None = None,
**kwargs: Any,
) â†’ Iterator[BaseMessageChunk]
Default implementation of stream, which calls invoke.

Subclasses should override this method if they support streaming output.

Parameters
:
input (LanguageModelInput) â€“ The input to the Runnable.

config (Optional[RunnableConfig]) â€“ The config to use for the Runnable. Defaults to None.

kwargs (Any) â€“ Additional keyword arguments to pass to the Runnable.

stop (Optional[list[str]])

Yields
:
The output of the Runnable.

Return type
:
Iterator[BaseMessageChunk]

with_alisteners(
*,
on_start: AsyncListener | None = None,
on_end: AsyncListener | None = None,
on_error: AsyncListener | None = None,
) â†’ Runnable[Input, Output]
Bind async lifecycle listeners to a Runnable, returning a new Runnable.

on_start: Asynchronously called before the Runnable starts running. on_end: Asynchronously called after the Runnable finishes running. on_error: Asynchronously called if the Runnable throws an error.

The Run object contains information about the run, including its id, type, input, output, error, start_time, end_time, and any tags or metadata added to the run.

Parameters
:
on_start (Optional[AsyncListener]) â€“ Asynchronously called before the Runnable starts running. Defaults to None.

on_end (Optional[AsyncListener]) â€“ Asynchronously called after the Runnable finishes running. Defaults to None.

on_error (Optional[AsyncListener]) â€“ Asynchronously called if the Runnable throws an error. Defaults to None.

Returns
:
A new Runnable with the listeners bound.

Return type
:
Runnable[Input, Output]

Example:

from langchain_core.runnables import RunnableLambda, Runnable
from datetime import datetime, timezone
import time
import asyncio

def format_t(timestamp: float) -> str:
    return datetime.fromtimestamp(timestamp, tz=timezone.utc).isoformat()

async def test_runnable(time_to_sleep : int):
    print(f"Runnable[{time_to_sleep}s]: starts at {format_t(time.time())}")
    await asyncio.sleep(time_to_sleep)
    print(f"Runnable[{time_to_sleep}s]: ends at {format_t(time.time())}")

async def fn_start(run_obj : Runnable):
    print(f"on start callback starts at {format_t(time.time())}")
    await asyncio.sleep(3)
    print(f"on start callback ends at {format_t(time.time())}")

async def fn_end(run_obj : Runnable):
    print(f"on end callback starts at {format_t(time.time())}")
    await asyncio.sleep(2)
    print(f"on end callback ends at {format_t(time.time())}")

runnable = RunnableLambda(test_runnable).with_alisteners(
    on_start=fn_start,
    on_end=fn_end
)
async def concurrent_runs():
    await asyncio.gather(runnable.ainvoke(2), runnable.ainvoke(3))

asyncio.run(concurrent_runs())
Result:
on start callback starts at 2025-03-01T07:05:22.875378+00:00
on start callback starts at 2025-03-01T07:05:22.875495+00:00
on start callback ends at 2025-03-01T07:05:25.878862+00:00
on start callback ends at 2025-03-01T07:05:25.878947+00:00
Runnable[2s]: starts at 2025-03-01T07:05:25.879392+00:00
Runnable[3s]: starts at 2025-03-01T07:05:25.879804+00:00
Runnable[2s]: ends at 2025-03-01T07:05:27.881998+00:00
on end callback starts at 2025-03-01T07:05:27.882360+00:00
Runnable[3s]: ends at 2025-03-01T07:05:28.881737+00:00
on end callback starts at 2025-03-01T07:05:28.882428+00:00
on end callback ends at 2025-03-01T07:05:29.883893+00:00
on end callback ends at 2025-03-01T07:05:30.884831+00:00
with_config(
config: RunnableConfig | None = None,
**kwargs: Any,
) â†’ Runnable[Input, Output]
Bind config to a Runnable, returning a new Runnable.

Parameters
:
config (RunnableConfig | None) â€“ The config to bind to the Runnable.

kwargs (Any) â€“ Additional keyword arguments to pass to the Runnable.

Returns
:
A new Runnable with the config bound.

Return type
:
Runnable[Input, Output]

with_fallbacks(fallbacks: Sequence[Runnable[Input, Output]], *, exceptions_to_handle: tuple[type[BaseException], ...] = (<class 'Exception'>,), exception_key: Optional[str] = None) â†’ RunnableWithFallbacksT[Input, Output]
Add fallbacks to a Runnable, returning a new Runnable.

The new Runnable will try the original Runnable, and then each fallback in order, upon failures.

Parameters
:
fallbacks (Sequence[Runnable[Input, Output]]) â€“ A sequence of runnables to try if the original Runnable fails.

exceptions_to_handle (tuple[type[BaseException], ...]) â€“ A tuple of exception types to handle. Defaults to (Exception,).

exception_key (Optional[str]) â€“ If string is specified then handled exceptions will be passed to fallbacks as part of the input under the specified key. If None, exceptions will not be passed to fallbacks. If used, the base Runnable and its fallbacks must accept a dictionary as input. Defaults to None.

Returns
:
A new Runnable that will try the original Runnable, and then each fallback in order, upon failures.

Return type
:
RunnableWithFallbacksT[Input, Output]

Example

from typing import Iterator

from langchain_core.runnables import RunnableGenerator


def _generate_immediate_error(input: Iterator) -> Iterator[str]:
    raise ValueError()
    yield ""


def _generate(input: Iterator) -> Iterator[str]:
    yield from "foo bar"


runnable = RunnableGenerator(_generate_immediate_error).with_fallbacks(
    [RunnableGenerator(_generate)]
    )
print(''.join(runnable.stream({}))) #foo bar
Parameters
:
fallbacks (Sequence[Runnable[Input, Output]]) â€“ A sequence of runnables to try if the original Runnable fails.

exceptions_to_handle (tuple[type[BaseException], ...]) â€“ A tuple of exception types to handle.

exception_key (Optional[str]) â€“ If string is specified then handled exceptions will be passed to fallbacks as part of the input under the specified key. If None, exceptions will not be passed to fallbacks. If used, the base Runnable and its fallbacks must accept a dictionary as input.

Returns
:
A new Runnable that will try the original Runnable, and then each fallback in order, upon failures.

Return type
:
RunnableWithFallbacksT[Input, Output]

with_listeners(
*,
on_start: Callable[[Run], None] | Callable[[Run, RunnableConfig], None] | None = None,
on_end: Callable[[Run], None] | Callable[[Run, RunnableConfig], None] | None = None,
on_error: Callable[[Run], None] | Callable[[Run, RunnableConfig], None] | None = None,
) â†’ Runnable[Input, Output]
Bind lifecycle listeners to a Runnable, returning a new Runnable.

on_start: Called before the Runnable starts running, with the Run object. on_end: Called after the Runnable finishes running, with the Run object. on_error: Called if the Runnable throws an error, with the Run object.

The Run object contains information about the run, including its id, type, input, output, error, start_time, end_time, and any tags or metadata added to the run.

Parameters
:
on_start (Optional[Union[Callable[[Run], None], Callable[[Run, RunnableConfig], None]]]) â€“ Called before the Runnable starts running. Defaults to None.

on_end (Optional[Union[Callable[[Run], None], Callable[[Run, RunnableConfig], None]]]) â€“ Called after the Runnable finishes running. Defaults to None.

on_error (Optional[Union[Callable[[Run], None], Callable[[Run, RunnableConfig], None]]]) â€“ Called if the Runnable throws an error. Defaults to None.

Returns
:
A new Runnable with the listeners bound.

Return type
:
Runnable[Input, Output]

Example:

from langchain_core.runnables import RunnableLambda
from langchain_core.tracers.schemas import Run

import time

def test_runnable(time_to_sleep : int):
    time.sleep(time_to_sleep)

def fn_start(run_obj: Run):
    print("start_time:", run_obj.start_time)

def fn_end(run_obj: Run):
    print("end_time:", run_obj.end_time)

chain = RunnableLambda(test_runnable).with_listeners(
    on_start=fn_start,
    on_end=fn_end
)
chain.invoke(2)
with_retry(*, retry_if_exception_type: tuple[type[BaseException], ...] = (<class 'Exception'>,), wait_exponential_jitter: bool = True, exponential_jitter_params: Optional[ExponentialJitterParams] = None, stop_after_attempt: int = 3) â†’ Runnable[Input, Output]
Create a new Runnable that retries the original Runnable on exceptions.

Parameters
:
retry_if_exception_type (tuple[type[BaseException], ...]) â€“ A tuple of exception types to retry on. Defaults to (Exception,).

wait_exponential_jitter (bool) â€“ Whether to add jitter to the wait time between retries. Defaults to True.

stop_after_attempt (int) â€“ The maximum number of attempts to make before giving up. Defaults to 3.

exponential_jitter_params (Optional[ExponentialJitterParams]) â€“ Parameters for tenacity.wait_exponential_jitter. Namely: initial, max, exp_base, and jitter (all float values).

Returns
:
A new Runnable that retries the original Runnable on exceptions.

Return type
:
Runnable[Input, Output]

Example:

from langchain_core.runnables import RunnableLambda

count = 0


def _lambda(x: int) -> None:
    global count
    count = count + 1
    if x == 1:
        raise ValueError("x is 1")
    else:
         pass


runnable = RunnableLambda(_lambda)
try:
    runnable.with_retry(
        stop_after_attempt=2,
        retry_if_exception_type=(ValueError,),
    ).invoke(1)
except ValueError:
    pass

assert (count == 2)
with_structured_output(
schema: Dict | Type[BaseModel],
method: Literal['function_calling', 'json_mode'] | None = 'function_calling',
*,
include_raw: bool = False,
**kwargs: Any,
) â†’ Runnable[PromptValue | str | Sequence[BaseMessage | list[str] | tuple[str, str] | str | dict[str, Any]], Dict | BaseModel][source]
Model wrapper that returns outputs formatted to match the given schema.

Parameters
:
schema (Dict | Type[BaseModel]) â€“

The output schema. Can be passed in as:
an OpenAI function/tool schema,

a JSON Schema,

a TypedDict class,

or a Pydantic class.

If schema is a Pydantic class then the model output will be a Pydantic instance of that class, and the model-generated fields will be validated by the Pydantic class. Otherwise the model output will be a dict and will not be validated. See langchain_core.utils.function_calling.convert_to_openai_tool() for more on how to properly specify types and descriptions of schema fields when specifying a Pydantic or TypedDict class.

include_raw (bool) â€“ If False then only the parsed structured output is returned. If an error occurs during model output parsing it will be raised. If True then both the raw model response (a BaseMessage) and the parsed model response will be returned. If an error occurs during output parsing it will be caught and returned as well. The final output is always a dict with keys â€œrawâ€, â€œparsedâ€, and â€œparsing_errorâ€.

method (Literal['function_calling', 'json_mode'] | None)

kwargs (Any)

Returns
:
A Runnable that takes same inputs as a langchain_core.language_models.chat.BaseChatModel.

If include_raw is False and schema is a Pydantic class, Runnable outputs an instance of schema (i.e., a Pydantic object).

Otherwise, if include_raw is False then Runnable outputs a dict.

If
include_raw
is True, then Runnable outputs a dict with keys:
"raw": BaseMessage

"parsed": None if there was a parsing error, otherwise the type depends on the schema as described above.

"parsing_error": Optional[BaseException]

Return type
:
Runnable[PromptValue | str | Sequence[BaseMessage | list[str] | tuple[str, str] | str | dict[str, Any]], Dict | BaseModel]

Example: Pydantic schema (include_raw=False):
from pydantic import BaseModel

class AnswerWithJustification(BaseModel):
    '''An answer to the user question along with justification for the answer.'''
    answer: str
    justification: str

llm = ChatModel(model="model-name", temperature=0)
structured_llm = llm.with_structured_output(AnswerWithJustification)

structured_llm.invoke("What weighs more a pound of bricks or a pound of feathers")

# -> AnswerWithJustification(
#     answer='They weigh the same',
#     justification='Both a pound of bricks and a pound of feathers weigh one pound. The weight is the same, but the volume or density of the objects may differ.'
# )
Example: Pydantic schema (include_raw=True):
from pydantic import BaseModel

class AnswerWithJustification(BaseModel):
    '''An answer to the user question along with justification for the answer.'''
    answer: str
    justification: str

llm = ChatModel(model="model-name", temperature=0)
structured_llm = llm.with_structured_output(AnswerWithJustification, include_raw=True)

structured_llm.invoke("What weighs more a pound of bricks or a pound of feathers")
# -> {
#     'raw': AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_Ao02pnFYXD6GN1yzc0uXPsvF', 'function': {'arguments': '{"answer":"They weigh the same.","justification":"Both a pound of bricks and a pound of feathers weigh one pound. The weight is the same, but the volume or density of the objects may differ."}', 'name': 'AnswerWithJustification'}, 'type': 'function'}]}),
#     'parsed': AnswerWithJustification(answer='They weigh the same.', justification='Both a pound of bricks and a pound of feathers weigh one pound. The weight is the same, but the volume or density of the objects may differ.'),
#     'parsing_error': None
# }
Example: Dict schema (include_raw=False):
from pydantic import BaseModel
from langchain_core.utils.function_calling import convert_to_openai_tool

class AnswerWithJustification(BaseModel):
    '''An answer to the user question along with justification for the answer.'''
    answer: str
    justification: str

dict_schema = convert_to_openai_tool(AnswerWithJustification)
llm = ChatModel(model="model-name", temperature=0)
structured_llm = llm.with_structured_output(dict_schema)

structured_llm.invoke("What weighs more a pound of bricks or a pound of feathers")
# -> {
#     'answer': 'They weigh the same',
#     'justification': 'Both a pound of bricks and a pound of feathers weigh one pound. The weight is the same, but the volume and density of the two substances differ.'
# }
Changed in version 0.2.26: Added support for TypedDict class.

with_types(
*,
input_type: type[Input] | None = None,
output_type: type[Output] | None = None,
) â†’ Runnable[Input, Output]
Bind input and output types to a Runnable, returning a new Runnable.

Parameters
:
input_type (type[Input] | None) â€“ The input type to bind to the Runnable. Defaults to None.

output_type (type[Output] | None) â€“ The output type to bind to the Runnable. Defaults to None.

Returns
:
A new Runnable with the types bound.

Return type
:
Runnable[Input, Output]

property async_client: GenerativeServiceAsyncClient